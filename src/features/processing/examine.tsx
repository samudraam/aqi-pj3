import { useMemo, useState, useEffect, useCallback } from "react";
import { Box, Typography, Paper, Chip, Fab } from "@mui/material";
import { motion } from "framer-motion";
import magnifierSrc from "../../assets/magnifier.png";
const particleO3 = `${import.meta.env.BASE_URL}thumbnail_new_O3.png`;
const particlePM25 = `${import.meta.env.BASE_URL}thumbnail_new_PM2.5.png`;
const particlePM10 = `${import.meta.env.BASE_URL}thumbnail_new_PM10.png`;
const particleCO2 = `${import.meta.env.BASE_URL}thumbnail_new_CO2.png`;
const particleNO2 = `${import.meta.env.BASE_URL}thumbnail_new_NO2.png`;
import ArrowForward from "@mui/icons-material/ArrowForward";
import { useNavigate } from "react-router-dom";
import Timeline from "../../components/timeline";
type ParticleId = "pm10" | "pm25" | "o3" | "co" | "no2";
import ArrowBackIcon from "@mui/icons-material/ArrowBack";
const health = `${import.meta.env.BASE_URL}health.png`;

type ParticleMeta = {
  id: ParticleId;
  label: string;
  description: string;
  healthImpact: string;
  image: string;
};

type ParticleInstance = ParticleMeta & {
  top: string;
  left: string;
};

const baseParticles: ParticleMeta[] = [
  {
    id: "pm10",
    label: "PM10",
    description:
      "Coarse particulate matter with a diameter of 10 μm or less. Often dust, pollen, or mold.",
    healthImpact:
      "Irritates the eyes, nose, and throat. Can worsen asthma and other respiratory conditions.",
    image: particlePM10,
  },
  {
    id: "pm25",
    label: "PM2.5",
    description:
      "Fine particulate matter 2.5 μm or smaller. Generated by combustion, smoke, and industrial emissions.",
    healthImpact:
      "Enters deep into lungs and bloodstream, increasing risk of heart and lung disease.",
    image: particlePM25,
  },
  {
    id: "o3",
    label: "Ozone (O₃)",
    description:
      "Ground-level ozone created when sunlight reacts with pollutants from vehicles and industry.",
    healthImpact:
      "Triggers chest tightness and coughing, and inflames the airways even in healthy people.",
    image: particleO3,
  },
  {
    id: "co",
    label: "Carbon Monoxide (CO)",
    description:
      "Colorless, odorless, and toxic gas produced by incomplete combustion of fossil fuels and biomass.",
    healthImpact:
      "Exposure to high levels can cause headaches, dizziness, and impaired judgment. Can be fatal in high concentrations.",
    image: particleCO2,
  },
  {
    id: "no2",
    label: "Nitrogen Dioxide (NO₂)",
    description:
      "Reddish-brown gas from vehicle exhaust and power plants. A key contributor to smog.",
    healthImpact:
      "Irritates airways, reduces lung function, and can increase susceptibility to infections.",
    image: particleNO2,
  },
];

const ExaminePage = () => {
  /**
   * Generates non-overlapping particle positions using collision detection.
   * Particles are 96x96 pixels, so we ensure minimum spacing between them.
   */
  const particleInstances = useMemo<ParticleInstance[]>(() => {
    // Assume viewport dimensions for collision detection calculations
    // Using a standard desktop viewport size
    const viewportWidth = 1920;
    const viewportHeight = 1080;

    // Particle dimensions in pixels
    const particleSize = 96;
    // Minimum spacing between particles (particle size + padding)
    const minSpacing = particleSize + 20;

    // Define valid placement area (avoiding info box on left and buttons on bottom)
    const minTopPercent = 15;
    const maxTopPercent = 75; // Leave space for bottom buttons
    const minLeftPercent = 30; // Avoid info box area (~400px)
    const maxLeftPercent = 80;

    const placedParticles: Array<{ top: number; left: number }> = [];
    const maxAttempts = 1000;

    return baseParticles.map((particle) => {
      let attempts = 0;
      let topPercent = minTopPercent;
      let leftPercent = minLeftPercent;
      let isValidPosition = false;

      // Try to find a non-overlapping position
      while (!isValidPosition && attempts < maxAttempts) {
        topPercent = Math.round(
          minTopPercent + Math.random() * (maxTopPercent - minTopPercent)
        );
        leftPercent = Math.round(
          minLeftPercent + Math.random() * (maxLeftPercent - minLeftPercent)
        );

        // Convert percentages to pixel coordinates for collision detection
        const topPx = (topPercent / 100) * viewportHeight;
        const leftPx = (leftPercent / 100) * viewportWidth;

        // Check collision with all previously placed particles
        isValidPosition = placedParticles.every((placed) => {
          const placedTopPx = (placed.top / 100) * viewportHeight;
          const placedLeftPx = (placed.left / 100) * viewportWidth;

          // Calculate distance between particle centers
          const centerTopPx = topPx + particleSize / 2;
          const centerLeftPx = leftPx + particleSize / 2;
          const placedCenterTopPx = placedTopPx + particleSize / 2;
          const placedCenterLeftPx = placedLeftPx + particleSize / 2;

          const distanceX = Math.abs(centerLeftPx - placedCenterLeftPx);
          const distanceY = Math.abs(centerTopPx - placedCenterTopPx);

          // Check if particles overlap (distance between centers should be >= minSpacing)
          return distanceX >= minSpacing || distanceY >= minSpacing;
        });

        attempts++;
      }

      // If we couldn't find a position after max attempts, use the last generated position
      // This should rarely happen with 5 particles
      const finalTop = topPercent;
      const finalLeft = leftPercent;

      placedParticles.push({ top: finalTop, left: finalLeft });

      return {
        ...particle,
        top: `${finalTop}%`,
        left: `${finalLeft}%`,
      };
    });
  }, []);

  const [activeParticle, setActiveParticle] = useState<ParticleInstance | null>(
    null
  );
  const [cursorPosition, setCursorPosition] = useState({ x: 0, y: 0 });
  const [cursorVisible, setCursorVisible] = useState(false);
  const [hoveredId, setHoveredId] = useState<ParticleId | null>(null);
  const navigate = useNavigate();

  useEffect(() => {
    console.debug("hoveredId changed", hoveredId);
  }, [hoveredId]);

  const handleActivate = (particle: ParticleInstance) => {
    console.debug("activate", particle.id);
    setActiveParticle(particle);
    setHoveredId(particle.id);
  };

  const handlePointerLeave = (particleId?: ParticleId) => {
    const idToClear = particleId ?? hoveredId;
    console.debug("pointer leave", idToClear);
    if (idToClear) {
      setHoveredId((current) => (current === idToClear ? null : current));
    }
    setActiveParticle(null);
  };

  const handleNavigateNext = useCallback(() => {
    navigate("/particles-debug");
  }, [navigate]);

  const handleNavigatePrevious = useCallback(() => {
    navigate("/mist");
  }, [navigate]);

  return (
    <Box
      component="main"
      role="main"
      sx={{
        minHeight: "100vh",
        minWidth: "100vw",
        position: "relative",
        overflow: "hidden",
        backgroundImage: "linear-gradient(180deg, #6CB2CE 0%, #FFFFFF 72%)",
        backgroundSize: "cover",
        backgroundPosition: "center",
        backgroundRepeat: "no-repeat",
        cursor: "none",
      }}
      onPointerMove={(event) => {
        setCursorPosition({ x: event.clientX, y: event.clientY });
        setCursorVisible(true);
      }}
      onPointerLeave={() => {
        setCursorVisible(false);
      }}
    >
      <Timeline currentStep="discover" />
      {particleInstances.map((particle) => {
        const isActive = hoveredId === particle.id;
        return (
          <motion.img
            key={particle.id}
            src={particle.image}
            alt={`${particle.label} particle icon`}
            initial={{ opacity: 0.55, scale: 0.9 }}
            animate={{
              opacity: isActive ? 1 : 0.55,
              scale: isActive ? 1.05 : 0.9,
            }}
            transition={{ duration: 0.2, ease: "easeOut" }}
            onPointerEnter={() => handleActivate(particle)}
            onPointerDown={() => handleActivate(particle)}
            onFocus={() => handleActivate(particle)}
            onPointerLeave={() => handlePointerLeave(particle.id)}
            onBlur={() => handlePointerLeave(particle.id)}
            tabIndex={0}
            style={{
              position: "absolute",
              top: particle.top,
              left: particle.left,
              width: 96,
              height: 96,
              pointerEvents: "auto",
              filter: isActive ? "blur(0px)" : "blur(5px)",
              transition:
                "filter 220ms ease, opacity 200ms ease, transform 200ms ease",
            }}
          />
        );
      })}

      {activeParticle && (
        <motion.div
          initial={{ opacity: 0, y: 8 }}
          animate={{ opacity: 1, y: 0 }}
          exit={{ opacity: 0, y: 8 }}
          transition={{ duration: 0.18, ease: "easeOut" }}
          style={{
            position: "fixed",
            top: 120,
            left: 24,
            pointerEvents: "none",
            zIndex: 200,
          }}
        >
          <Paper
            elevation={6}
            sx={{
              px: 2.5,
              py: 2,
              maxWidth: 320,
              borderRadius: 3,
              boxShadow: 6,
              pointerEvents: "none",
            }}
          >
            <Chip
              label={activeParticle.label}
              sx={{ mb: 1.5, fontWeight: 600, backgroundColor: "#FFD400" }}
              aria-hidden
            />
            <Typography variant="body1" sx={{ mb: 1.5, fontWeight: 500 }}>
              {activeParticle.description}
            </Typography>
            <Box
              sx={{ mb: 1.5, display: "flex", gap: 1, alignItems: "center" }}
            >
              <img src={health} alt="Health Impact" />
              <Typography
                variant="body2"
                color="text.secondary"
                sx={{ fontWeight: 600 }}
              >
                Health Impact
              </Typography>
            </Box>
            <Typography variant="body2" color="text.secondary">
              {activeParticle.healthImpact}
            </Typography>
          </Paper>
        </motion.div>
      )}

      <motion.img
        src={magnifierSrc}
        alt="Magnifying glass cursor"
        initial={{ opacity: 0 }}
        animate={
          cursorVisible ? { opacity: 1, scale: 3 } : { opacity: 0, scale: 0.9 }
        }
        transition={{ duration: 0.2, ease: "easeOut" }}
        style={{
          position: "fixed",
          top: cursorPosition.y - 48,
          left: cursorPosition.x - 32,
          width: 96,
          height: 96,
          pointerEvents: "none",
          zIndex: 20,
        }}
      />
      <Fab
        color="success"
        aria-label="Go back"
        onClick={handleNavigatePrevious}
        sx={{
          position: "absolute",
          bottom: 24,
          left: 24,
          width: 72,
          height: 72,
          backgroundColor: "#FFD400",
          "&:hover": { backgroundColor: "#FFE254" },
        }}
      >
        <ArrowBackIcon sx={{ fontSize: 36, color: "#000000" }} />
      </Fab>

      <Fab
        color="success"
        aria-label="Show results"
        onClick={handleNavigateNext}
        sx={{
          position: "absolute",
          bottom: 24,
          right: 24,
          width: 72,
          height: 72,
          backgroundColor: "#FFD400",
          "&:hover": { backgroundColor: "#FFE254" },
        }}
      >
        <ArrowForward sx={{ fontSize: 36, color: "#000000" }} />
      </Fab>
    </Box>
  );
};

export default ExaminePage;
